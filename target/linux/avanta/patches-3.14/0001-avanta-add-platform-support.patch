From bc536470468384a59b50c026277d1f221ef09f1a Mon Sep 17 00:00:00 2001
From: Claudio Leite <leitec@staticky.com>
Date: Sat, 26 Jul 2014 21:31:58 -0400
Subject: [PATCH 1/4] avanta: add platform support

---
 arch/arm/Kconfig                                |  18 +
 arch/arm/Kconfig.debug                          |   7 +-
 arch/arm/Makefile                               |   1 +
 arch/arm/boot/dts/Makefile                      |   1 +
 arch/arm/boot/dts/avanta-6560.dtsi              | 147 +++++
 arch/arm/boot/dts/avanta-mi424wr.dts            | 179 ++++++
 arch/arm/boot/dts/avanta.dtsi                   | 276 +++++++++
 arch/arm/mach-avanta/Kconfig                    |  25 +
 arch/arm/mach-avanta/Makefile                   |   4 +
 arch/arm/mach-avanta/Makefile.boot              |   3 +
 arch/arm/mach-avanta/board-dt.c                 | 147 +++++
 arch/arm/mach-avanta/common.c                   | 745 ++++++++++++++++++++++++
 arch/arm/mach-avanta/common.h                   |  87 +++
 arch/arm/mach-avanta/include/mach/bridge-regs.h |  83 +++
 arch/arm/mach-avanta/include/mach/entry-macro.S |  34 ++
 arch/arm/mach-avanta/include/mach/hardware.h    |  14 +
 arch/arm/mach-avanta/include/mach/irqs.h        |  65 +++
 arch/arm/mach-avanta/include/mach/kirkwood.h    | 142 +++++
 arch/arm/mach-avanta/include/mach/timex.h       |  10 +
 arch/arm/mach-avanta/include/mach/uncompress.h  |  46 ++
 arch/arm/mach-avanta/pcie.c                     | 296 ++++++++++
 arch/arm/mach-avanta/pm.c                       |  73 +++
 arch/arm/mm/Kconfig                             |   2 +-
 23 files changed, 2401 insertions(+), 4 deletions(-)
 create mode 100644 arch/arm/boot/dts/avanta-6560.dtsi
 create mode 100644 arch/arm/boot/dts/avanta-mi424wr.dts
 create mode 100644 arch/arm/boot/dts/avanta.dtsi
 create mode 100644 arch/arm/mach-avanta/Kconfig
 create mode 100644 arch/arm/mach-avanta/Makefile
 create mode 100644 arch/arm/mach-avanta/Makefile.boot
 create mode 100644 arch/arm/mach-avanta/board-dt.c
 create mode 100644 arch/arm/mach-avanta/common.c
 create mode 100644 arch/arm/mach-avanta/common.h
 create mode 100644 arch/arm/mach-avanta/include/mach/bridge-regs.h
 create mode 100644 arch/arm/mach-avanta/include/mach/entry-macro.S
 create mode 100644 arch/arm/mach-avanta/include/mach/hardware.h
 create mode 100644 arch/arm/mach-avanta/include/mach/irqs.h
 create mode 100644 arch/arm/mach-avanta/include/mach/kirkwood.h
 create mode 100644 arch/arm/mach-avanta/include/mach/timex.h
 create mode 100644 arch/arm/mach-avanta/include/mach/uncompress.h
 create mode 100644 arch/arm/mach-avanta/pcie.c
 create mode 100644 arch/arm/mach-avanta/pm.c

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 44298ad..ceb8159 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -554,6 +554,22 @@ config ARCH_KIRKWOOD
 	  Support for the following Marvell Kirkwood series SoCs:
 	  88F6180, 88F6192 and 88F6281.
 
+config ARCH_AVANTA
+	bool "Marvell Avanta"
+	select ARCH_HAS_CPUFREQ
+	select ARCH_REQUIRE_GPIOLIB
+	select CPU_FEROCEON
+	select GENERIC_CLOCKEVENTS
+	select MVEBU_MBUS
+	select PCI
+	select PCI_QUIRKS
+	select PINCTRL
+	select PINCTRL_KIRKWOOD
+	select PLAT_ORION_LEGACY
+	help
+	  Support for the following Marvell Kirkwood series SoCs:
+	  88F6560
+
 config ARCH_MV78XX0
 	bool "Marvell MV78xx0"
 	select ARCH_REQUIRE_GPIOLIB
@@ -934,6 +950,8 @@ source "arch/arm/mach-mvebu/Kconfig"
 
 source "arch/arm/mach-at91/Kconfig"
 
+source "arch/arm/mach-avanta/Kconfig"
+
 source "arch/arm/mach-bcm/Kconfig"
 
 source "arch/arm/mach-bcm2835/Kconfig"
diff --git a/arch/arm/Kconfig.debug b/arch/arm/Kconfig.debug
index 0531da8..05c6fd5 100644
--- a/arch/arm/Kconfig.debug
+++ b/arch/arm/Kconfig.debug
@@ -1002,7 +1002,8 @@ config DEBUG_UART_8250
 		(FOOTBRIDGE && !DEBUG_DC21285_PORT) || \
 		ARCH_GEMINI || ARCH_IOP13XX || ARCH_IOP32X || \
 		ARCH_IOP33X || ARCH_IXP4XX || ARCH_KIRKWOOD || \
-		ARCH_LPC32XX || ARCH_MV78XX0 || ARCH_ORION5X || ARCH_RPC
+		ARCH_LPC32XX || ARCH_MV78XX0 || ARCH_ORION5X || \
+		ARCH_AVANTA || ARCH_RPC
 
 config DEBUG_UART_PHYS
 	hex "Physical base address of debug UART"
@@ -1051,7 +1052,7 @@ config DEBUG_UART_PHYS
 	default 0xf0000be0 if ARCH_EBSA110
 	default 0xf1012000 if DEBUG_MVEBU_UART_ALTERNATE
 	default 0xf1012000 if ARCH_DOVE || ARCH_KIRKWOOD || ARCH_MV78XX0 || \
-				ARCH_ORION5X
+				ARCH_ORION5X || ARCH_AVANTA
 	default 0xf7fc9000 if DEBUG_BERLIN_UART
 	default 0xf8b00000 if DEBUG_HI3716_UART
 	default 0xfcb00000 if DEBUG_HI3620_UART
@@ -1107,7 +1108,7 @@ config DEBUG_UART_VIRT
 	default 0xfec20000 if DEBUG_DAVINCI_DMx_UART0
 	default 0xfed0c000 if DEBUG_DAVINCI_DA8XX_UART1
 	default 0xfed0d000 if DEBUG_DAVINCI_DA8XX_UART2
-	default 0xfed12000 if ARCH_KIRKWOOD
+	default 0xfed12000 if ARCH_KIRKWOOD || ARCH_AVANTA
 	default 0xfedc0000 if ARCH_EP93XX
 	default 0xfee003f8 if FOOTBRIDGE
 	default 0xfee08300 if DEBUG_DAVINCI_TNETV107X_UART1
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index 014c0d1..9c09233 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -147,6 +147,7 @@ textofs-$(CONFIG_ARCH_MSM8960) := 0x00208000
 # Machine directory name.  This list is sorted alphanumerically
 # by CONFIG_* macro name.
 machine-$(CONFIG_ARCH_AT91)		+= at91
+machine-$(CONFIG_ARCH_AVANTA)		+= avanta
 machine-$(CONFIG_ARCH_BCM)		+= bcm
 machine-$(CONFIG_ARCH_BCM2835)		+= bcm2835
 machine-$(CONFIG_ARCH_BERLIN)		+= berlin
diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index 43db984..882cd2e 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -83,6 +83,7 @@ dtb-$(CONFIG_ARCH_HIGHBANK) += highbank.dtb \
 dtb-$(CONFIG_ARCH_INTEGRATOR) += integratorap.dtb \
 	integratorcp.dtb
 dtb-$(CONFIG_ARCH_LPC32XX) += ea3250.dtb phy3250.dtb
+dtb-$(CONFIG_ARCH_AVANTA) += avanta-mi424wr.dtb
 dtb-$(CONFIG_ARCH_KIRKWOOD) += kirkwood-cloudbox.dtb \
 	kirkwood-db-88f6281.dtb \
 	kirkwood-db-88f6282.dtb \
diff --git a/arch/arm/boot/dts/avanta-6560.dtsi b/arch/arm/boot/dts/avanta-6560.dtsi
new file mode 100644
index 0000000..e491567
--- /dev/null
+++ b/arch/arm/boot/dts/avanta-6560.dtsi
@@ -0,0 +1,147 @@
+/ {
+	mbus {
+		pcie-controller {
+			compatible = "marvell,kirkwood-pcie";
+			status = "disabled";
+			device_type = "pci";
+
+			#address-cells = <3>;
+			#size-cells = <2>;
+
+			bus-range = <0x00 0xff>;
+
+			ranges =
+			       <0x82000000 0 0x40000 MBUS_ID(0xf0, 0x01) 0x40000 0 0x00002000
+			        0x82000000 0 0x44000 MBUS_ID(0xf0, 0x01) 0x44000 0 0x00002000
+				0x82000000 0 0x80000 MBUS_ID(0xf0, 0x01) 0x80000 0 0x00002000
+				0x82000000 0x1 0     MBUS_ID(0x04, 0xe8) 0       1 0 /* Port 0.0 MEM */
+				0x81000000 0x1 0     MBUS_ID(0x04, 0xe0) 0       1 0 /* Port 0.0 IO  */
+				0x82000000 0x2 0     MBUS_ID(0x04, 0xd8) 0       1 0 /* Port 1.0 MEM */
+				0x81000000 0x2 0     MBUS_ID(0x04, 0xd0) 0       1 0 /* Port 1.0 IO  */>;
+
+			pcie@1,0 {
+				device_type = "pci";
+				assigned-addresses = <0x82000800 0 0x00040000 0 0x2000>;
+				reg = <0x0800 0 0 0 0>;
+				#address-cells = <3>;
+				#size-cells = <2>;
+				#interrupt-cells = <1>;
+				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+				interrupt-map-mask = <0 0 0 0>;
+				interrupt-map = <0 0 0 0 &intc 25>;
+				marvell,pcie-port = <0>;
+				marvell,pcie-lane = <0>;
+				clocks = <&gate_clk 2>;
+				status = "disabled";
+			};
+
+			pcie@2,0 {
+				device_type = "pci";
+				assigned-addresses = <0x82001000 0 0x00044000 0 0x2000>;
+				reg = <0x1000 0 0 0 0>;
+				#address-cells = <3>;
+				#size-cells = <2>;
+				#interrupt-cells = <1>;
+				ranges = <0x82000000 0 0 0x82000000 0x2 0 1 0
+					  0x81000000 0 0 0x81000000 0x2 0 1 0>;
+				interrupt-map-mask = <0 0 0 0>;
+				interrupt-map = <0 0 0 0 &intc 24>;
+				marvell,pcie-port = <1>;
+				marvell,pcie-lane = <0>;
+				clocks = <&gate_clk 18>;
+				status = "disabled";
+			};
+		};
+	};
+	ocp@f1000000 {
+		pinctrl: pinctrl@10000 {
+			compatible = "marvell,88f6282-pinctrl";
+			reg = <0x10000 0x20>;
+
+			pmx_nand: pmx-nand {
+				marvell,pins = "mpp0", "mpp1", "mpp2", "mpp3",
+							"mpp4", "mpp5", "mpp18", "mpp19";
+				marvell,function = "nand";
+			};
+			pmx_sata0: pmx-sata0 {
+				marvell,pins = "mpp5", "mpp21", "mpp23";
+				marvell,function = "sata0";
+			};
+			pmx_spi: pmx-spi {
+				marvell,pins = "mpp0", "mpp1", "mpp2", "mpp3";
+				marvell,function = "spi";
+			};
+			pmx_twsi0: pmx-twsi0 {
+				marvell,pins = "mpp8", "mpp9";
+				marvell,function = "twsi0";
+			};
+			pmx_twsi1: pmx-twsi1 {
+				marvell,pins = "mpp36", "mpp37";
+				marvell,function = "twsi1";
+			};
+			pmx_uart0: pmx-uart0 {
+				marvell,pins = "mpp10", "mpp11";
+				marvell,function = "uart0";
+			};
+			pmx_uart1: pmx-uart1 {
+				marvell,pins = "mpp13", "mpp14";
+				marvell,function = "uart1";
+			};
+			pmx_sdio: pmx-sdio {
+				marvell,pins = "mpp12", "mpp13", "mpp14",
+					       "mpp15", "mpp16", "mpp17";
+				marvell,function = "sdio";
+			};
+		};
+
+		thermal@10078 {
+			compatible = "marvell,kirkwood-thermal";
+			reg = <0x10078 0x4>;
+			status = "okay";
+		};
+
+		rtc@10300 {
+			compatible = "marvell,kirkwood-rtc", "marvell,orion-rtc";
+			reg = <0x10300 0x20>;
+			interrupts = <32>;
+			clocks = <&gate_clk 7>;
+		};
+
+		i2c@11100 {
+			compatible = "marvell,mv64xxx-i2c";
+			reg = <0x11100 0x20>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			interrupts = <25>;
+			clock-frequency = <100000>;
+			clocks = <&gate_clk 7>;
+			status = "disabled";
+		};
+
+		sata@80000 {
+			compatible = "marvell,orion-sata";
+			reg = <0x80000 0x5000>;
+			interrupts = <22>;
+			clocks = <&gate_clk 14>, <&gate_clk 15>;
+			clock-names = "0", "1";
+			phys = <&sata_phy0>;
+			phy-names = "port0";
+			status = "disabled";
+		};
+
+		mvsdio@90000 {
+			compatible = "marvell,orion-sdio";
+			reg = <0x90000 0x200>;
+			interrupts = <18>;
+			clocks = <&gate_clk 4>;
+			pinctrl-0 = <&pmx_sdio>;
+			pinctrl-names = "default";
+			bus-width = <4>;
+			cap-sdio-irq;
+			cap-sd-highspeed;
+			cap-mmc-highspeed;
+			status = "disabled";
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/avanta-mi424wr.dts b/arch/arm/boot/dts/avanta-mi424wr.dts
new file mode 100644
index 0000000..93206a0
--- /dev/null
+++ b/arch/arm/boot/dts/avanta-mi424wr.dts
@@ -0,0 +1,179 @@
+/*
+ * kirkwood-ea4500.dts - Device Tree file for Linksys EA4500
+ *
+ * (c) 2013 Jonas Gorski <jogo@openwrt.org>
+ * (c) 2013 Deutsche Telekom Innovation Laboratories
+ * (c) 2014 Luka Perkov <luka@openwrt.org>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+/dts-v1/;
+
+#include "avanta.dtsi"
+#include "avanta-6560.dtsi"
+
+/ {
+	model = "Actiontec MI424WR-I";
+	compatible = "actiontec,mi424wr-i", "marvell,kirkwood-88f6282", "marvell,kirkwood";
+
+	memory {
+		device_type = "memory";
+		reg = <0x00000000 0x8000000>;
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,115200n8 earlyprintk";
+	};
+
+
+	mbus {
+		pcie-controller {
+			status = "okay";
+
+			pcie@1,0 {
+				status = "okay";
+			};
+
+/*
+			pcie@2,0 {
+				status = "okay";
+			};
+*/
+		};
+	};
+
+	ocp@f1000000 {
+/*
+		pinctrl: pinctrl@10000 {
+			pmx_led_white_health: pmx-led-white-health {
+				marvell,pins = "mpp7";
+				marvell,function = "gpo";
+			};
+			pmx_led_white_pulse: pmx-led-white-pulse {
+				marvell,pins = "mpp14";
+				marvell,function = "gpio";
+			};
+			pmx_btn_wps: pmx-btn-wps {
+				marvell,pins = "mpp47";
+				marvell,function = "gpio";
+			};
+			pmx_btn_reset: pmx-btn-reset {
+				marvell,pins = "mpp48";
+				marvell,function = "gpio";
+			};
+		};
+*/
+
+		rtc@10300 {
+			status = "disabled";
+		};
+
+		serial@12000 {
+			status = "okay";
+		};
+	};
+
+/*
+	gpio_keys {
+		compatible = "gpio-keys";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		pinctrl-0 = < &pmx_btn_wps &pmx_btn_reset >;
+		pinctrl-names = "default";
+
+		button@15 {
+			label = "WPS Button";
+			linux,code = <KEY_WPS_BUTTON>;
+			gpios = <&gpio1 15 GPIO_ACTIVE_LOW>;
+		};
+
+		button@16 {
+			label = "Reset Button";
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio1 16 GPIO_ACTIVE_LOW>;
+		};
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+		pinctrl-0 = < &pmx_led_white_health &pmx_led_white_pulse >;
+		pinctrl-names = "default";
+
+		white-health {
+			label = "ea4500:white:health";
+			gpios = <&gpio0 7 GPIO_ACTIVE_HIGH>;
+		};
+
+		white-pulse {
+			label = "ea4500:white:pulse";
+			gpios = <&gpio0 14 GPIO_ACTIVE_HIGH>;
+		};
+	};
+*/
+	mvsw6171 {
+		compatible = "marvell,88e6171";
+		status = "okay";
+		reg = <0x8>;
+
+		mii-bus = <&mdio>;
+		cpu-port-0 = <5>;
+		cpu-port-1 = <6>;
+		is-indirect;
+	};
+};
+
+&nand {
+	status = "okay";
+/*
+	pinctrl-0 = <&pmx_nand_none>;
+	pinctrl-names = "default";
+*/
+
+	partition@0 {
+		label = "u-boot";
+		reg = <0 0x200000>;
+	};
+
+	partition@200000 {
+		label = "jffs2";
+		reg = <0x200000 0x2000000>;
+	};
+
+
+	partition@3000000 {
+		label = "kernel";
+		reg = <0x3000000 0x200000>;
+	};
+
+	partition@4000000 {
+		label = "root";
+		reg = <0x4000000 0x4000000>;
+	};
+};
+
+&mdio {
+	status = "okay";
+
+	phy0: ethernet-phy@9 {
+		reg = <9>;
+	};
+};
+
+&eth0 {
+	status = "okay";
+	phy-mode = "gmii";
+
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+};
+
+&eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id";
+};
diff --git a/arch/arm/boot/dts/avanta.dtsi b/arch/arm/boot/dts/avanta.dtsi
new file mode 100644
index 0000000..4339462
--- /dev/null
+++ b/arch/arm/boot/dts/avanta.dtsi
@@ -0,0 +1,276 @@
+/include/ "skeleton.dtsi"
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/gpio/gpio.h>
+
+#define MBUS_ID(target,attributes) (((target) << 24) | ((attributes) << 16))
+
+/ {
+	compatible = "marvell,kirkwood";
+	interrupt-parent = <&intc>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "marvell,feroceon";
+			reg = <0>;
+			clocks = <&core_clk 1>, <&core_clk 3>, <&gate_clk 11>;
+			clock-names = "cpu_clk", "ddrclk", "powersave";
+		};
+	};
+
+	aliases {
+	       gpio0 = &gpio0;
+	       /*gpio1 = &gpio1;*/
+	};
+
+	mbus {
+		compatible = "marvell,kirkwood-mbus", "simple-bus";
+		#address-cells = <2>;
+		#size-cells = <1>;
+		/* If a board file needs to change this ranges it must replace it completely */
+		ranges = <MBUS_ID(0xf0, 0x01) 0 0xf1000000 0x100000	/* internal-regs */
+			  MBUS_ID(0x01, 0x2f) 0 0xf4000000 0x10000	/* nand flash */
+			  MBUS_ID(0x03, 0x01) 0 0xf5000000 0x10000	/* crypto sram */
+			  >;
+		controller = <&mbusc>;
+		pcie-mem-aperture = <0xf3000000 0x1000000>; /* 16 MiB memory space */
+		pcie-io-aperture  = <0xf2000000 0x100000>;   /*   1 MiB    I/O space */
+
+		crypto@0301 {
+			compatible = "marvell,orion-crypto";
+			reg = <MBUS_ID(0xf0, 0x01) 0x30000 0x10000>,
+			      <MBUS_ID(0x03, 0x01) 0 0x800>;
+			reg-names = "regs", "sram";
+			interrupts = <22>;
+			clocks = <&gate_clk 17>;
+			status = "okay";
+		};
+
+		nand: nand@012f {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			cle = <0>;
+			ale = <1>;
+			bank-width = <1>;
+			compatible = "marvell,orion-nand";
+			reg = <MBUS_ID(0x01, 0x2f) 0 0x400>;
+			chip-delay = <25>;
+			/* set partition map and/or chip-delay in board dts */
+			clocks = <&gate_clk 7>;
+			status = "disabled";
+		};
+	};
+
+	ocp@f1000000 {
+		compatible = "simple-bus";
+		ranges = <0x00000000 0xf1000000 0x0100000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		core_clk: core-clocks@10030 {
+			compatible = "marvell,kirkwood-core-clock";
+			reg = <0x10030 0x4>;
+			#clock-cells = <1>;
+		};
+
+		spi@10600 {
+			compatible = "marvell,orion-spi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			cell-index = <0>;
+			interrupts = <19>;
+			reg = <0x10600 0x28>;
+			clocks = <&gate_clk 7>;
+			status = "disabled";
+		};
+
+		gpio0: gpio@10100 {
+			compatible = "marvell,orion-gpio";
+			#gpio-cells = <2>;
+			gpio-controller;
+			reg = <0x10100 0x40>;
+			ngpios = <32>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			interrupts = <36>, <37>, <38>, <39>;
+			clocks = <&gate_clk 7>;
+		};
+
+/*
+		gpio1: gpio@10140 {
+			compatible = "marvell,orion-gpio";
+			#gpio-cells = <2>;
+			gpio-controller;
+			reg = <0x10140 0x40>;
+			ngpios = <18>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			interrupts = <39>, <40>, <41>;
+			clocks = <&gate_clk 7>;
+		};
+*/
+
+		i2c@11000 {
+			compatible = "marvell,mv64xxx-i2c";
+			reg = <0x11000 0x20>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			interrupts = <18>;
+			clock-frequency = <100000>;
+			clocks = <&gate_clk 7>;
+			status = "disabled";
+		};
+
+		serial@12000 {
+			compatible = "ns16550a";
+			reg = <0x12000 0x100>;
+			reg-shift = <2>;
+			interrupts = <33>;
+			clocks = <&gate_clk 7>;
+			status = "disabled";
+		};
+
+		serial@12100 {
+			compatible = "ns16550a";
+			reg = <0x12100 0x100>;
+			reg-shift = <2>;
+			interrupts = <34>;
+			clocks = <&gate_clk 7>;
+			status = "disabled";
+		};
+
+		mbusc: mbus-controller@20000 {
+			compatible = "marvell,mbus-controller";
+			reg = <0x20000 0x80>, <0x1500 0x20>;
+		};
+
+		bridge_intc: bridge-interrupt-ctrl@20110 {
+			compatible = "marvell,orion-bridge-intc";
+			interrupt-controller;
+			#interrupt-cells = <1>;
+			reg = <0x20110 0x8>;
+			interrupts = <1>;
+			marvell,#interrupts = <6>;
+		};
+
+		gate_clk: clock-gating-control@2011c {
+			compatible = "marvell,kirkwood-gating-clock";
+			reg = <0x2011c 0x4>;
+			clocks = <&core_clk 0>;
+			#clock-cells = <1>;
+		};
+
+		intc: main-interrupt-ctrl@20200 {
+			compatible = "marvell,orion-intc";
+			interrupt-controller;
+			#interrupt-cells = <1>;
+			reg = <0x20200 0x10>, <0x20210 0x10>;
+		};
+
+		timer: timer@20300 {
+			compatible = "marvell,orion-timer";
+			reg = <0x20300 0x20>;
+			interrupt-parent = <&bridge_intc>;
+			interrupts = <1>, <2>;
+			clocks = <&core_clk 0>;
+		};
+
+		wdt: watchdog-timer@20300 {
+			compatible = "marvell,orion-wdt";
+			reg = <0x20300 0x28>;
+			interrupt-parent = <&bridge_intc>;
+			interrupts = <3>;
+			clocks = <&gate_clk 7>;
+			status = "disabled";
+		};
+
+		ehci@50000 {
+			compatible = "marvell,orion-ehci";
+			reg = <0x50000 0x1000>;
+			interrupts = <23>;
+			clocks = <&gate_clk 3>;
+			status = "okay";
+		};
+
+		eth0: ethernet@74000 {
+			compatible = "marvell,armada-370-neta";
+			reg = <0x74000 0x4000>;
+			interrupts = <11>;
+			clocks = <&gate_clk 19>;
+			status = "disabled";
+		};
+
+		eth1: ethernet@70000 {
+			compatible = "marvell,armada-370-neta";
+			reg = <0x70000 0x4000>;
+			interrupts = <7>;
+			clocks = <&gate_clk 0>;
+			status = "disabled";
+		};
+
+		xor@60800 {
+			compatible = "marvell,orion-xor";
+			reg = <0x60800 0x100
+			       0x60A00 0x100>;
+			status = "okay";
+			clocks = <&gate_clk 8>;
+
+			xor00 {
+			      interrupts = <26>;
+			      dmacap,memcpy;
+			      dmacap,xor;
+			};
+			xor01 {
+			      interrupts = <27>;
+			      dmacap,memcpy;
+			      dmacap,xor;
+			      dmacap,memset;
+			};
+		};
+
+/*
+		xor@60900 {
+			compatible = "marvell,orion-xor";
+			reg = <0x60900 0x100
+			       0x60B00 0x100>;
+			status = "okay";
+			clocks = <&gate_clk 16>;
+
+			xor00 {
+			      interrupts = <7>;
+			      dmacap,memcpy;
+			      dmacap,xor;
+			};
+			xor01 {
+			      interrupts = <8>;
+			      dmacap,memcpy;
+			      dmacap,xor;
+			      dmacap,memset;
+			};
+		};
+*/
+
+		mdio: mdio-bus@72004 {
+			compatible = "marvell,orion-mdio";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x72004 0x84>;
+			interrupts = <4>;
+			clocks = <&gate_clk 0>;
+			status = "disabled";
+			/* add phy nodes in board file */
+		};
+
+		sata_phy0: sata-phy@82000 {
+			compatible = "marvell,mvebu-sata-phy";
+			reg = <0x82000 0x0334>;
+			clocks = <&gate_clk 14>;
+			clock-names = "sata";
+			#phy-cells = <0>;
+			status = "disabled";
+		};
+	};
+};
diff --git a/arch/arm/mach-avanta/Kconfig b/arch/arm/mach-avanta/Kconfig
new file mode 100644
index 0000000..8487631
--- /dev/null
+++ b/arch/arm/mach-avanta/Kconfig
@@ -0,0 +1,25 @@
+if ARCH_AVANTA
+
+menu "Marvell Avanta Implementations"
+
+comment "Device tree entries"
+
+config ARCH_AVANTA_DT
+	bool "Marvell Avanta Flattened Device Tree"
+	select KIRKWOOD_CLK
+	select OF_IRQ
+	select ORION_IRQCHIP
+	select ORION_TIMER
+	select POWER_SUPPLY
+	select POWER_RESET
+	select POWER_RESET_GPIO
+	select REGULATOR
+	select REGULATOR_FIXED_VOLTAGE
+	select USE_OF
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Marvell Avanta using flattened device tree.
+
+endmenu
+
+endif
diff --git a/arch/arm/mach-avanta/Makefile b/arch/arm/mach-avanta/Makefile
new file mode 100644
index 0000000..99ec348
--- /dev/null
+++ b/arch/arm/mach-avanta/Makefile
@@ -0,0 +1,4 @@
+obj-y				+= common.o pcie.o
+obj-$(CONFIG_PM)		+= pm.o
+
+obj-$(CONFIG_ARCH_AVANTA_DT)		+= board-dt.o
diff --git a/arch/arm/mach-avanta/Makefile.boot b/arch/arm/mach-avanta/Makefile.boot
new file mode 100644
index 0000000..760a0ef
--- /dev/null
+++ b/arch/arm/mach-avanta/Makefile.boot
@@ -0,0 +1,3 @@
+   zreladdr-y	+= 0x00008000
+params_phys-y	:= 0x00000100
+initrd_phys-y	:= 0x00800000
diff --git a/arch/arm/mach-avanta/board-dt.c b/arch/arm/mach-avanta/board-dt.c
new file mode 100644
index 0000000..37990e7
--- /dev/null
+++ b/arch/arm/mach-avanta/board-dt.c
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2012 (C), Jason Cooper <jason@lakedaemon.net>
+ *
+ * arch/arm/mach-kirkwood/board-dt.c
+ *
+ * Flattened Device Tree board initialization
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/clk.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_net.h>
+#include <linux/of_platform.h>
+#include <linux/dma-mapping.h>
+#include <linux/irqchip.h>
+#include <linux/kexec.h>
+#include <asm/mach/arch.h>
+#include <mach/bridge-regs.h>
+#include <plat/common.h>
+#include "common.h"
+
+#define MV643XX_ETH_MAC_ADDR_LOW	0x0414
+#define MV643XX_ETH_MAC_ADDR_HIGH	0x0418
+
+static void __init kirkwood_dt_eth_fixup(void)
+{
+	struct device_node *np;
+
+	/*
+	 * The ethernet interfaces forget the MAC address assigned by u-boot
+	 * if the clocks are turned off. Usually, u-boot on kirkwood boards
+	 * has no DT support to properly set local-mac-address property.
+	 * As a workaround, we get the MAC address from mv643xx_eth registers
+	 * and update the port device node if no valid MAC address is set.
+	 */
+	for_each_compatible_node(np, NULL, "marvell,kirkwood-eth-port") {
+		struct device_node *pnp = of_get_parent(np);
+		struct clk *clk;
+		struct property *pmac;
+		void __iomem *io;
+		u8 *macaddr;
+		u32 reg;
+
+		if (!pnp)
+			continue;
+
+		/* skip disabled nodes or nodes with valid MAC address*/
+		if (!of_device_is_available(pnp) || of_get_mac_address(np))
+			goto eth_fixup_skip;
+
+		clk = of_clk_get(pnp, 0);
+		if (IS_ERR(clk))
+			goto eth_fixup_skip;
+
+		io = of_iomap(pnp, 0);
+		if (!io)
+			goto eth_fixup_no_map;
+
+		/* ensure port clock is not gated to not hang CPU */
+		clk_prepare_enable(clk);
+
+		/* store MAC address register contents in local-mac-address */
+		pr_err(FW_INFO "%s: local-mac-address is not set\n",
+		       np->full_name);
+
+		pmac = kzalloc(sizeof(*pmac) + 6, GFP_KERNEL);
+		if (!pmac)
+			goto eth_fixup_no_mem;
+
+		pmac->value = pmac + 1;
+		pmac->length = 6;
+		pmac->name = kstrdup("local-mac-address", GFP_KERNEL);
+		if (!pmac->name) {
+			kfree(pmac);
+			goto eth_fixup_no_mem;
+		}
+
+		macaddr = pmac->value;
+		reg = readl(io + MV643XX_ETH_MAC_ADDR_HIGH);
+		macaddr[0] = (reg >> 24) & 0xff;
+		macaddr[1] = (reg >> 16) & 0xff;
+		macaddr[2] = (reg >> 8) & 0xff;
+		macaddr[3] = reg & 0xff;
+
+		reg = readl(io + MV643XX_ETH_MAC_ADDR_LOW);
+		macaddr[4] = (reg >> 8) & 0xff;
+		macaddr[5] = reg & 0xff;
+
+		of_update_property(np, pmac);
+
+eth_fixup_no_mem:
+		iounmap(io);
+		clk_disable_unprepare(clk);
+eth_fixup_no_map:
+		clk_put(clk);
+eth_fixup_skip:
+		of_node_put(pnp);
+	}
+}
+
+static void __init kirkwood_dt_init(void)
+{
+	pr_info("Kirkwood: %s.\n", kirkwood_id());
+
+	/*
+	 * Disable propagation of mbus errors to the CPU local bus,
+	 * as this causes mbus errors (which can occur for example
+	 * for PCI aborts) to throw CPU aborts, which we're not set
+	 * up to deal with.
+	 */
+	writel(readl(CPU_CONFIG) & ~CPU_CONFIG_ERROR_PROP, CPU_CONFIG);
+
+	BUG_ON(mvebu_mbus_dt_init());
+
+	kirkwood_l2_init();
+
+	kirkwood_cpufreq_init();
+	kirkwood_cpuidle_init();
+
+	kirkwood_pm_init();
+/*	kirkwood_dt_eth_fixup();	*/
+
+#ifdef CONFIG_KEXEC
+	kexec_reinit = kirkwood_enable_pcie;
+#endif
+
+	of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
+}
+
+static const char * const kirkwood_dt_board_compat[] = {
+	"marvell,kirkwood",
+	NULL
+};
+
+DT_MACHINE_START(KIRKWOOD_DT, "Marvell Avanta (Flattened Device Tree)")
+	/* Maintainer: Jason Cooper <jason@lakedaemon.net> */
+	.map_io		= kirkwood_map_io,
+	.init_machine	= kirkwood_dt_init,
+	.restart	= kirkwood_restart,
+	.dt_compat	= kirkwood_dt_board_compat,
+MACHINE_END
diff --git a/arch/arm/mach-avanta/common.c b/arch/arm/mach-avanta/common.c
new file mode 100644
index 0000000..f3407a5
--- /dev/null
+++ b/arch/arm/mach-avanta/common.c
@@ -0,0 +1,745 @@
+/*
+ * arch/arm/mach-kirkwood/common.c
+ *
+ * Core functions for Marvell Kirkwood SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/serial_8250.h>
+#include <linux/ata_platform.h>
+#include <linux/mtd/nand.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk-provider.h>
+#include <linux/spinlock.h>
+#include <linux/mv643xx_i2c.h>
+#include <linux/timex.h>
+#include <linux/kexec.h>
+#include <linux/reboot.h>
+#include <net/dsa.h>
+#include <asm/page.h>
+#include <asm/mach/map.h>
+#include <asm/mach/time.h>
+#include <mach/kirkwood.h>
+#include <mach/bridge-regs.h>
+#include <linux/platform_data/asoc-kirkwood.h>
+#include <plat/cache-feroceon-l2.h>
+#include <linux/platform_data/mmc-mvsdio.h>
+#include <linux/platform_data/mtd-orion_nand.h>
+#include <linux/platform_data/usb-ehci-orion.h>
+#include <plat/common.h>
+#include <plat/time.h>
+#include <linux/platform_data/dma-mv_xor.h>
+#include "common.h"
+
+/* These can go away once Kirkwood uses the mvebu-mbus DT binding */
+#define KIRKWOOD_MBUS_NAND_TARGET 0x01
+#define KIRKWOOD_MBUS_NAND_ATTR   0x2f
+#define KIRKWOOD_MBUS_SRAM_TARGET 0x03
+#define KIRKWOOD_MBUS_SRAM_ATTR   0x01
+
+/*****************************************************************************
+ * I/O Address Mapping
+ ****************************************************************************/
+static struct map_desc kirkwood_io_desc[] __initdata = {
+	{
+		.virtual	= (unsigned long) KIRKWOOD_REGS_VIRT_BASE,
+		.pfn		= __phys_to_pfn(KIRKWOOD_REGS_PHYS_BASE),
+		.length		= KIRKWOOD_REGS_SIZE,
+		.type		= MT_DEVICE,
+	},
+};
+
+void __init kirkwood_map_io(void)
+{
+	iotable_init(kirkwood_io_desc, ARRAY_SIZE(kirkwood_io_desc));
+}
+
+/*****************************************************************************
+ * CLK tree
+ ****************************************************************************/
+
+static void enable_sata0(void)
+{
+	/* Enable PLL and IVREF */
+	writel(readl(SATA0_PHY_MODE_2) | 0xf, SATA0_PHY_MODE_2);
+	/* Enable PHY */
+	writel(readl(SATA0_IF_CTRL) & ~0x200, SATA0_IF_CTRL);
+}
+
+static void disable_sata0(void)
+{
+	/* Disable PLL and IVREF */
+	writel(readl(SATA0_PHY_MODE_2) & ~0xf, SATA0_PHY_MODE_2);
+	/* Disable PHY */
+	writel(readl(SATA0_IF_CTRL) | 0x200, SATA0_IF_CTRL);
+}
+
+static void enable_sata1(void)
+{
+	/* Enable PLL and IVREF */
+	writel(readl(SATA1_PHY_MODE_2) | 0xf, SATA1_PHY_MODE_2);
+	/* Enable PHY */
+	writel(readl(SATA1_IF_CTRL) & ~0x200, SATA1_IF_CTRL);
+}
+
+static void disable_sata1(void)
+{
+	/* Disable PLL and IVREF */
+	writel(readl(SATA1_PHY_MODE_2) & ~0xf, SATA1_PHY_MODE_2);
+	/* Disable PHY */
+	writel(readl(SATA1_IF_CTRL) | 0x200, SATA1_IF_CTRL);
+}
+
+static void disable_pcie0(void)
+{
+	writel(readl(PCIE_LINK_CTRL) | 0x10, PCIE_LINK_CTRL);
+	while (1)
+		if (readl(PCIE_STATUS) & 0x1)
+			break;
+	writel(readl(PCIE_LINK_CTRL) & ~0x10, PCIE_LINK_CTRL);
+}
+
+static void disable_pcie1(void)
+{
+	u32 dev, rev;
+
+	kirkwood_pcie_id(&dev, &rev);
+
+	if (dev == MV88F6282_DEV_ID) {
+		writel(readl(PCIE1_LINK_CTRL) | 0x10, PCIE1_LINK_CTRL);
+		while (1)
+			if (readl(PCIE1_STATUS) & 0x1)
+				break;
+		writel(readl(PCIE1_LINK_CTRL) & ~0x10, PCIE1_LINK_CTRL);
+	}
+}
+
+/* An extended version of the gated clk. This calls fn_en()/fn_dis
+ * before enabling/disabling the clock.  We use this to turn on/off
+ * PHYs etc.  */
+struct clk_gate_fn {
+	struct clk_gate gate;
+	void (*fn_en)(void);
+	void (*fn_dis)(void);
+};
+
+#define to_clk_gate_fn(_gate) container_of(_gate, struct clk_gate_fn, gate)
+#define to_clk_gate(_hw) container_of(_hw, struct clk_gate, hw)
+
+static int clk_gate_fn_enable(struct clk_hw *hw)
+{
+	struct clk_gate *gate = to_clk_gate(hw);
+	struct clk_gate_fn *gate_fn = to_clk_gate_fn(gate);
+	int ret;
+
+	ret = clk_gate_ops.enable(hw);
+	if (!ret && gate_fn->fn_en)
+		gate_fn->fn_en();
+
+	return ret;
+}
+
+static void clk_gate_fn_disable(struct clk_hw *hw)
+{
+	struct clk_gate *gate = to_clk_gate(hw);
+	struct clk_gate_fn *gate_fn = to_clk_gate_fn(gate);
+
+	if (gate_fn->fn_dis)
+		gate_fn->fn_dis();
+
+	clk_gate_ops.disable(hw);
+}
+
+static struct clk_ops clk_gate_fn_ops;
+
+static struct clk __init *clk_register_gate_fn(struct device *dev,
+		const char *name,
+		const char *parent_name, unsigned long flags,
+		void __iomem *reg, u8 bit_idx,
+		u8 clk_gate_flags, spinlock_t *lock,
+		void (*fn_en)(void), void (*fn_dis)(void))
+{
+	struct clk_gate_fn *gate_fn;
+	struct clk *clk;
+	struct clk_init_data init;
+
+	gate_fn = kzalloc(sizeof(struct clk_gate_fn), GFP_KERNEL);
+	if (!gate_fn) {
+		pr_err("%s: could not allocate gated clk\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	init.name = name;
+	init.ops = &clk_gate_fn_ops;
+	init.flags = flags;
+	init.parent_names = (parent_name ? &parent_name : NULL);
+	init.num_parents = (parent_name ? 1 : 0);
+
+	/* struct clk_gate assignments */
+	gate_fn->gate.reg = reg;
+	gate_fn->gate.bit_idx = bit_idx;
+	gate_fn->gate.flags = clk_gate_flags;
+	gate_fn->gate.lock = lock;
+	gate_fn->gate.hw.init = &init;
+	gate_fn->fn_en = fn_en;
+	gate_fn->fn_dis = fn_dis;
+
+	/* ops is the gate ops, but with our enable/disable functions */
+	if (clk_gate_fn_ops.enable != clk_gate_fn_enable ||
+	    clk_gate_fn_ops.disable != clk_gate_fn_disable) {
+		clk_gate_fn_ops = clk_gate_ops;
+		clk_gate_fn_ops.enable = clk_gate_fn_enable;
+		clk_gate_fn_ops.disable = clk_gate_fn_disable;
+	}
+
+	clk = clk_register(dev, &gate_fn->gate.hw);
+
+	if (IS_ERR(clk))
+		kfree(gate_fn);
+
+	return clk;
+}
+
+static DEFINE_SPINLOCK(gating_lock);
+static struct clk *tclk;
+
+static struct clk __init *kirkwood_register_gate(const char *name, u8 bit_idx)
+{
+	return clk_register_gate(NULL, name, "tclk", 0, CLOCK_GATING_CTRL,
+				 bit_idx, 0, &gating_lock);
+}
+
+static struct clk __init *kirkwood_register_gate_fn(const char *name,
+						    u8 bit_idx,
+						    void (*fn_en)(void),
+						    void (*fn_dis)(void))
+{
+	return clk_register_gate_fn(NULL, name, "tclk", 0, CLOCK_GATING_CTRL,
+				    bit_idx, 0, &gating_lock, fn_en, fn_dis);
+}
+
+static struct clk *ge0, *ge1;
+
+void __init kirkwood_clk_init(void)
+{
+	struct clk *runit, *sata0, *sata1, *usb0, *sdio;
+	struct clk *crypto, *xor0, *xor1, *pex0, *pex1, *audio;
+
+	tclk = clk_register_fixed_rate(NULL, "tclk", NULL,
+				       CLK_IS_ROOT, kirkwood_tclk);
+
+	runit = kirkwood_register_gate("runit",  CGC_BIT_RUNIT);
+	ge0 = kirkwood_register_gate("ge0",    CGC_BIT_GE0);
+	ge1 = kirkwood_register_gate("ge1",    CGC_BIT_GE1);
+	sata0 = kirkwood_register_gate_fn("sata0",  CGC_BIT_SATA0,
+					  enable_sata0, disable_sata0);
+	sata1 = kirkwood_register_gate_fn("sata1",  CGC_BIT_SATA1,
+					  enable_sata1, disable_sata1);
+	usb0 = kirkwood_register_gate("usb0",   CGC_BIT_USB0);
+	sdio = kirkwood_register_gate("sdio",   CGC_BIT_SDIO);
+	crypto = kirkwood_register_gate("crypto", CGC_BIT_CRYPTO);
+	xor0 = kirkwood_register_gate("xor0",   CGC_BIT_XOR0);
+	xor1 = kirkwood_register_gate("xor1",   CGC_BIT_XOR1);
+	pex0 = kirkwood_register_gate_fn("pex0",   CGC_BIT_PEX0,
+					 NULL, disable_pcie0);
+	pex1 = kirkwood_register_gate_fn("pex1",   CGC_BIT_PEX1,
+					 NULL, disable_pcie1);
+	audio = kirkwood_register_gate("audio",  CGC_BIT_AUDIO);
+	kirkwood_register_gate("tdm",    CGC_BIT_TDM);
+	kirkwood_register_gate("tsu",    CGC_BIT_TSU);
+
+	/* clkdev entries, mapping clks to devices */
+	orion_clkdev_add(NULL, "orion_spi.0", runit);
+	orion_clkdev_add(NULL, "orion_spi.1", runit);
+	orion_clkdev_add(NULL, MV643XX_ETH_NAME ".0", ge0);
+	orion_clkdev_add(NULL, MV643XX_ETH_NAME ".1", ge1);
+	orion_clkdev_add(NULL, "orion_wdt", tclk);
+	orion_clkdev_add("0", "sata_mv.0", sata0);
+	orion_clkdev_add("1", "sata_mv.0", sata1);
+	orion_clkdev_add(NULL, "orion-ehci.0", usb0);
+	orion_clkdev_add(NULL, "orion_nand", runit);
+	orion_clkdev_add(NULL, "mvsdio", sdio);
+	orion_clkdev_add(NULL, "mv_crypto", crypto);
+	orion_clkdev_add(NULL, MV_XOR_NAME ".0", xor0);
+	orion_clkdev_add(NULL, MV_XOR_NAME ".1", xor1);
+	orion_clkdev_add("0", "pcie", pex0);
+	orion_clkdev_add("1", "pcie", pex1);
+	orion_clkdev_add(NULL, "mvebu-audio", audio);
+	orion_clkdev_add(NULL, MV64XXX_I2C_CTLR_NAME ".0", runit);
+	orion_clkdev_add(NULL, MV64XXX_I2C_CTLR_NAME ".1", runit);
+
+	/* Marvell says runit is used by SPI, UART, NAND, TWSI, ...,
+	 * so should never be gated.
+	 */
+	clk_prepare_enable(runit);
+}
+
+/*****************************************************************************
+ * EHCI0
+ ****************************************************************************/
+void __init kirkwood_ehci_init(void)
+{
+	orion_ehci_init(USB_PHYS_BASE, IRQ_KIRKWOOD_USB, EHCI_PHY_NA);
+}
+
+
+/*****************************************************************************
+ * GE00
+ ****************************************************************************/
+void __init kirkwood_ge00_init(struct mv643xx_eth_platform_data *eth_data)
+{
+	orion_ge00_init(eth_data,
+			GE00_PHYS_BASE, IRQ_KIRKWOOD_GE00_SUM,
+			IRQ_KIRKWOOD_GE00_ERR, 1600);
+	/* The interface forgets the MAC address assigned by u-boot if
+	the clock is turned off, so claim the clk now. */
+	clk_prepare_enable(ge0);
+}
+
+
+/*****************************************************************************
+ * GE01
+ ****************************************************************************/
+void __init kirkwood_ge01_init(struct mv643xx_eth_platform_data *eth_data)
+{
+	orion_ge01_init(eth_data,
+			GE01_PHYS_BASE, IRQ_KIRKWOOD_GE01_SUM,
+			IRQ_KIRKWOOD_GE01_ERR, 1600);
+	clk_prepare_enable(ge1);
+}
+
+
+/*****************************************************************************
+ * Ethernet switch
+ ****************************************************************************/
+void __init kirkwood_ge00_switch_init(struct dsa_platform_data *d, int irq)
+{
+	orion_ge00_switch_init(d, irq);
+}
+
+
+/*****************************************************************************
+ * NAND flash
+ ****************************************************************************/
+static struct resource kirkwood_nand_resource = {
+	.flags		= IORESOURCE_MEM,
+	.start		= KIRKWOOD_NAND_MEM_PHYS_BASE,
+	.end		= KIRKWOOD_NAND_MEM_PHYS_BASE +
+				KIRKWOOD_NAND_MEM_SIZE - 1,
+};
+
+static struct orion_nand_data kirkwood_nand_data = {
+	.cle		= 0,
+	.ale		= 1,
+	.width		= 8,
+};
+
+static struct platform_device kirkwood_nand_flash = {
+	.name		= "orion_nand",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= &kirkwood_nand_data,
+	},
+	.resource	= &kirkwood_nand_resource,
+	.num_resources	= 1,
+};
+
+void __init kirkwood_nand_init(struct mtd_partition *parts, int nr_parts,
+			       int chip_delay)
+{
+	kirkwood_nand_data.parts = parts;
+	kirkwood_nand_data.nr_parts = nr_parts;
+	kirkwood_nand_data.chip_delay = chip_delay;
+	platform_device_register(&kirkwood_nand_flash);
+}
+
+void __init kirkwood_nand_init_rnb(struct mtd_partition *parts, int nr_parts,
+				   int (*dev_ready)(struct mtd_info *))
+{
+	kirkwood_nand_data.parts = parts;
+	kirkwood_nand_data.nr_parts = nr_parts;
+	kirkwood_nand_data.dev_ready = dev_ready;
+	platform_device_register(&kirkwood_nand_flash);
+}
+
+/*****************************************************************************
+ * SoC RTC
+ ****************************************************************************/
+static void __init kirkwood_rtc_init(void)
+{
+	orion_rtc_init(RTC_PHYS_BASE, IRQ_KIRKWOOD_RTC);
+}
+
+
+/*****************************************************************************
+ * SATA
+ ****************************************************************************/
+void __init kirkwood_sata_init(struct mv_sata_platform_data *sata_data)
+{
+	orion_sata_init(sata_data, SATA_PHYS_BASE, IRQ_KIRKWOOD_SATA);
+}
+
+
+/*****************************************************************************
+ * SD/SDIO/MMC
+ ****************************************************************************/
+static struct resource mvsdio_resources[] = {
+	[0] = {
+		.start	= SDIO_PHYS_BASE,
+		.end	= SDIO_PHYS_BASE + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_KIRKWOOD_SDIO,
+		.end	= IRQ_KIRKWOOD_SDIO,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static u64 mvsdio_dmamask = DMA_BIT_MASK(32);
+
+static struct platform_device kirkwood_sdio = {
+	.name		= "mvsdio",
+	.id		= -1,
+	.dev		= {
+		.dma_mask = &mvsdio_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+	.num_resources	= ARRAY_SIZE(mvsdio_resources),
+	.resource	= mvsdio_resources,
+};
+
+void __init kirkwood_sdio_init(struct mvsdio_platform_data *mvsdio_data)
+{
+	u32 dev, rev;
+
+	kirkwood_pcie_id(&dev, &rev);
+	if (rev == 0 && dev != MV88F6282_DEV_ID) /* catch all Kirkwood Z0's */
+		mvsdio_data->clock = 100000000;
+	else
+		mvsdio_data->clock = 200000000;
+	kirkwood_sdio.dev.platform_data = mvsdio_data;
+	platform_device_register(&kirkwood_sdio);
+}
+
+
+/*****************************************************************************
+ * SPI
+ ****************************************************************************/
+void __init kirkwood_spi_init(void)
+{
+	orion_spi_init(SPI_PHYS_BASE);
+}
+
+
+/*****************************************************************************
+ * I2C
+ ****************************************************************************/
+void __init kirkwood_i2c_init(void)
+{
+	orion_i2c_init(I2C_PHYS_BASE, IRQ_KIRKWOOD_TWSI, 8);
+}
+
+
+/*****************************************************************************
+ * UART0
+ ****************************************************************************/
+
+void __init kirkwood_uart0_init(void)
+{
+	orion_uart0_init(UART0_VIRT_BASE, UART0_PHYS_BASE,
+			 IRQ_KIRKWOOD_UART_0, tclk);
+}
+
+
+/*****************************************************************************
+ * UART1
+ ****************************************************************************/
+void __init kirkwood_uart1_init(void)
+{
+	orion_uart1_init(UART1_VIRT_BASE, UART1_PHYS_BASE,
+			 IRQ_KIRKWOOD_UART_1, tclk);
+}
+
+/*****************************************************************************
+ * Cryptographic Engines and Security Accelerator (CESA)
+ ****************************************************************************/
+void __init kirkwood_crypto_init(void)
+{
+	orion_crypto_init(CRYPTO_PHYS_BASE, KIRKWOOD_SRAM_PHYS_BASE,
+			  KIRKWOOD_SRAM_SIZE, IRQ_KIRKWOOD_CRYPTO);
+}
+
+
+/*****************************************************************************
+ * XOR0
+ ****************************************************************************/
+void __init kirkwood_xor0_init(void)
+{
+	orion_xor0_init(XOR0_PHYS_BASE, XOR0_HIGH_PHYS_BASE,
+			IRQ_KIRKWOOD_XOR_00, IRQ_KIRKWOOD_XOR_01);
+}
+
+
+/*****************************************************************************
+ * XOR1
+ ****************************************************************************/
+void __init kirkwood_xor1_init(void)
+{
+	orion_xor1_init(XOR1_PHYS_BASE, XOR1_HIGH_PHYS_BASE,
+			IRQ_KIRKWOOD_XOR_10, IRQ_KIRKWOOD_XOR_11);
+}
+
+
+/*****************************************************************************
+ * Watchdog
+ ****************************************************************************/
+void __init kirkwood_wdt_init(void)
+{
+	orion_wdt_init();
+}
+
+/*****************************************************************************
+ * CPU idle
+ ****************************************************************************/
+static struct resource kirkwood_cpuidle_resource[] = {
+	{
+		.flags	= IORESOURCE_MEM,
+		.start	= DDR_OPERATION_BASE,
+		.end	= DDR_OPERATION_BASE + 3,
+	},
+};
+
+static struct platform_device kirkwood_cpuidle = {
+	.name		= "kirkwood_cpuidle",
+	.id		= -1,
+	.resource	= kirkwood_cpuidle_resource,
+	.num_resources	= 1,
+};
+
+void __init kirkwood_cpuidle_init(void)
+{
+	platform_device_register(&kirkwood_cpuidle);
+}
+
+/*****************************************************************************
+ * Time handling
+ ****************************************************************************/
+void __init kirkwood_init_early(void)
+{
+	orion_time_set_base(TIMER_VIRT_BASE);
+}
+
+int kirkwood_tclk;
+
+static int __init kirkwood_find_tclk(void)
+{
+	u32 dev, rev;
+
+	kirkwood_pcie_id(&dev, &rev);
+
+	if (dev == MV88F6281_DEV_ID || dev == MV88F6282_DEV_ID)
+		if (((readl(SAMPLE_AT_RESET) >> 21) & 1) == 0)
+			return 200000000;
+
+	return 166666667;
+}
+
+void __init kirkwood_timer_init(void)
+{
+	kirkwood_tclk = kirkwood_find_tclk();
+
+	orion_time_init(BRIDGE_VIRT_BASE, BRIDGE_INT_TIMER1_CLR,
+			IRQ_KIRKWOOD_BRIDGE, kirkwood_tclk);
+}
+
+/*****************************************************************************
+ * Audio
+ ****************************************************************************/
+static struct resource kirkwood_audio_resources[] = {
+	[0] = {
+		.start  = AUDIO_PHYS_BASE,
+		.end    = AUDIO_PHYS_BASE + SZ_16K - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = IRQ_KIRKWOOD_I2S,
+		.end    = IRQ_KIRKWOOD_I2S,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct kirkwood_asoc_platform_data kirkwood_audio_data = {
+	.burst       = 128,
+};
+
+static struct platform_device kirkwood_audio_device = {
+	.name		= "mvebu-audio",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(kirkwood_audio_resources),
+	.resource	= kirkwood_audio_resources,
+	.dev		= {
+		.platform_data	= &kirkwood_audio_data,
+	},
+};
+
+void __init kirkwood_audio_init(void)
+{
+	platform_device_register(&kirkwood_audio_device);
+}
+
+/*****************************************************************************
+ * CPU Frequency
+ ****************************************************************************/
+static struct resource kirkwood_cpufreq_resources[] = {
+	[0] = {
+		.start  = CPU_CONTROL_PHYS,
+		.end    = CPU_CONTROL_PHYS + 3,
+		.flags  = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device kirkwood_cpufreq_device = {
+	.name		= "kirkwood-cpufreq",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(kirkwood_cpufreq_resources),
+	.resource	= kirkwood_cpufreq_resources,
+};
+
+void __init kirkwood_cpufreq_init(void)
+{
+	platform_device_register(&kirkwood_cpufreq_device);
+}
+
+/*****************************************************************************
+ * General
+ ****************************************************************************/
+/*
+ * Identify device ID and revision.
+ */
+char * __init kirkwood_id(void)
+{
+	u32 dev, rev;
+
+	kirkwood_pcie_id(&dev, &rev);
+
+	if (dev == MV88F6281_DEV_ID) {
+		if (rev == MV88F6281_REV_Z0)
+			return "MV88F6281-Z0";
+		else if (rev == MV88F6281_REV_A0)
+			return "MV88F6281-A0";
+		else if (rev == MV88F6281_REV_A1)
+			return "MV88F6281-A1";
+		else
+			return "MV88F6281-Rev-Unsupported";
+	} else if (dev == MV88F6192_DEV_ID) {
+		if (rev == MV88F6192_REV_Z0)
+			return "MV88F6192-Z0";
+		else if (rev == MV88F6192_REV_A0)
+			return "MV88F6192-A0";
+		else if (rev == MV88F6192_REV_A1)
+			return "MV88F6192-A1";
+		else
+			return "MV88F6192-Rev-Unsupported";
+	} else if (dev == MV88F6180_DEV_ID) {
+		if (rev == MV88F6180_REV_A0)
+			return "MV88F6180-Rev-A0";
+		else if (rev == MV88F6180_REV_A1)
+			return "MV88F6180-Rev-A1";
+		else
+			return "MV88F6180-Rev-Unsupported";
+	} else if (dev == MV88F6282_DEV_ID) {
+		if (rev == MV88F6282_REV_A0)
+			return "MV88F6282-Rev-A0";
+		else if (rev == MV88F6282_REV_A1)
+			return "MV88F6282-Rev-A1";
+		else
+			return "MV88F6282-Rev-Unsupported";
+	} else {
+		return "Device-Unknown";
+	}
+}
+
+void __init kirkwood_setup_wins(void)
+{
+	mvebu_mbus_add_window_by_id(KIRKWOOD_MBUS_NAND_TARGET,
+				    KIRKWOOD_MBUS_NAND_ATTR,
+				    KIRKWOOD_NAND_MEM_PHYS_BASE,
+				    KIRKWOOD_NAND_MEM_SIZE);
+	mvebu_mbus_add_window_by_id(KIRKWOOD_MBUS_SRAM_TARGET,
+				    KIRKWOOD_MBUS_SRAM_ATTR,
+				    KIRKWOOD_SRAM_PHYS_BASE,
+				    KIRKWOOD_SRAM_SIZE);
+}
+
+void __init kirkwood_l2_init(void)
+{
+#ifdef CONFIG_CACHE_FEROCEON_L2
+#ifdef CONFIG_CACHE_FEROCEON_L2_WRITETHROUGH
+	writel(readl(L2_CONFIG_REG) | L2_WRITETHROUGH, L2_CONFIG_REG);
+	feroceon_l2_init(1);
+#else
+	writel(readl(L2_CONFIG_REG) & ~L2_WRITETHROUGH, L2_CONFIG_REG);
+	feroceon_l2_init(0);
+#endif
+#endif
+}
+
+void __init kirkwood_init(void)
+{
+	pr_info("Kirkwood: %s, TCLK=%d.\n", kirkwood_id(), kirkwood_tclk);
+
+	/*
+	 * Disable propagation of mbus errors to the CPU local bus,
+	 * as this causes mbus errors (which can occur for example
+	 * for PCI aborts) to throw CPU aborts, which we're not set
+	 * up to deal with.
+	 */
+	writel(readl(CPU_CONFIG) & ~CPU_CONFIG_ERROR_PROP, CPU_CONFIG);
+
+	BUG_ON(mvebu_mbus_init("marvell,kirkwood-mbus",
+			BRIDGE_WINS_BASE, BRIDGE_WINS_SZ,
+			DDR_WINDOW_CPU_BASE, DDR_WINDOW_CPU_SZ));
+
+	kirkwood_setup_wins();
+
+	kirkwood_l2_init();
+
+	/* Setup root of clk tree */
+	kirkwood_clk_init();
+
+	/* internal devices that every board has */
+	kirkwood_rtc_init();
+	kirkwood_wdt_init();
+	kirkwood_xor0_init();
+	kirkwood_xor1_init();
+	kirkwood_crypto_init();
+
+	kirkwood_pm_init();
+	kirkwood_cpuidle_init();
+#ifdef CONFIG_KEXEC
+	kexec_reinit = kirkwood_enable_pcie;
+#endif
+}
+
+void kirkwood_restart(enum reboot_mode mode, const char *cmd)
+{
+	/*
+	 * Enable soft reset to assert RSTOUTn.
+	 */
+	writel(SOFT_RESET_OUT_EN, RSTOUTn_MASK);
+
+	/*
+	 * Assert soft reset.
+	 */
+	writel(SOFT_RESET, SYSTEM_SOFT_RESET);
+
+	while (1)
+		;
+}
diff --git a/arch/arm/mach-avanta/common.h b/arch/arm/mach-avanta/common.h
new file mode 100644
index 0000000..05fd648
--- /dev/null
+++ b/arch/arm/mach-avanta/common.h
@@ -0,0 +1,87 @@
+/*
+ * arch/arm/mach-kirkwood/common.h
+ *
+ * Core functions for Marvell Kirkwood SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ARCH_KIRKWOOD_COMMON_H
+#define __ARCH_KIRKWOOD_COMMON_H
+
+#include <linux/reboot.h>
+
+struct dsa_platform_data;
+struct mv643xx_eth_platform_data;
+struct mv_sata_platform_data;
+struct mvsdio_platform_data;
+struct mtd_partition;
+struct mtd_info;
+struct kirkwood_asoc_platform_data;
+
+#define KW_PCIE0	(1 << 0)
+#define KW_PCIE1	(1 << 1)
+
+/*
+ * Basic Kirkwood init functions used early by machine-setup.
+ */
+void kirkwood_map_io(void);
+void kirkwood_init(void);
+void kirkwood_init_early(void);
+void kirkwood_init_irq(void);
+
+void kirkwood_setup_wins(void);
+
+void kirkwood_enable_pcie(void);
+void kirkwood_pcie_id(u32 *dev, u32 *rev);
+
+void kirkwood_ehci_init(void);
+void kirkwood_ge00_init(struct mv643xx_eth_platform_data *eth_data);
+void kirkwood_ge01_init(struct mv643xx_eth_platform_data *eth_data);
+void kirkwood_ge00_switch_init(struct dsa_platform_data *d, int irq);
+void kirkwood_pcie_init(unsigned int portmask);
+void kirkwood_sata_init(struct mv_sata_platform_data *sata_data);
+void kirkwood_sdio_init(struct mvsdio_platform_data *mvsdio_data);
+void kirkwood_spi_init(void);
+void kirkwood_i2c_init(void);
+void kirkwood_uart0_init(void);
+void kirkwood_uart1_init(void);
+void kirkwood_nand_init(struct mtd_partition *parts, int nr_parts, int delay);
+void kirkwood_nand_init_rnb(struct mtd_partition *parts, int nr_parts,
+			    int (*dev_ready)(struct mtd_info *));
+void kirkwood_audio_init(void);
+void kirkwood_cpuidle_init(void);
+void kirkwood_cpufreq_init(void);
+
+void kirkwood_restart(enum reboot_mode, const char *);
+void kirkwood_clk_init(void);
+
+#ifdef CONFIG_PM
+void kirkwood_pm_init(void);
+#else
+static inline void kirkwood_pm_init(void) {};
+#endif
+
+/* board init functions for boards not fully converted to fdt */
+#ifdef CONFIG_MACH_MV88F6281GTW_GE_DT
+void mv88f6281gtw_ge_init(void);
+#else
+static inline void mv88f6281gtw_ge_init(void) {};
+#endif
+
+/* early init functions not converted to fdt yet */
+char *kirkwood_id(void);
+void kirkwood_l2_init(void);
+void kirkwood_wdt_init(void);
+void kirkwood_xor0_init(void);
+void kirkwood_xor1_init(void);
+void kirkwood_crypto_init(void);
+
+extern int kirkwood_tclk;
+extern void kirkwood_timer_init(void);
+
+#define ARRAY_AND_SIZE(x)	(x), ARRAY_SIZE(x)
+
+#endif
diff --git a/arch/arm/mach-avanta/include/mach/bridge-regs.h b/arch/arm/mach-avanta/include/mach/bridge-regs.h
new file mode 100644
index 0000000..8b9d1c9
--- /dev/null
+++ b/arch/arm/mach-avanta/include/mach/bridge-regs.h
@@ -0,0 +1,83 @@
+/*
+ * arch/arm/mach-kirkwood/include/mach/bridge-regs.h
+ *
+ * Mbus-L to Mbus Bridge Registers
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_BRIDGE_REGS_H
+#define __ASM_ARCH_BRIDGE_REGS_H
+
+#include <mach/kirkwood.h>
+
+#define CPU_CONFIG		(BRIDGE_VIRT_BASE + 0x0100)
+#define CPU_CONFIG_ERROR_PROP	0x00000004
+
+#define CPU_CONTROL		(BRIDGE_VIRT_BASE + 0x0104)
+#define CPU_CONTROL_PHYS	(BRIDGE_PHYS_BASE + 0x0104)
+#define CPU_RESET		0x00000002
+
+#define RSTOUTn_MASK		(BRIDGE_VIRT_BASE + 0x0108)
+#define SOFT_RESET_OUT_EN	0x00000004
+
+#define SYSTEM_SOFT_RESET	(BRIDGE_VIRT_BASE + 0x010c)
+#define SOFT_RESET		0x00000001
+
+#define BRIDGE_CAUSE		(BRIDGE_VIRT_BASE + 0x0110)
+
+#define BRIDGE_INT_TIMER1_CLR	(~0x0004)
+
+#define IRQ_VIRT_BASE		(BRIDGE_VIRT_BASE + 0x0200)
+#define IRQ_CAUSE_LOW_OFF	0x0000
+#define IRQ_MASK_LOW_OFF	0x0004
+#define IRQ_CAUSE_HIGH_OFF	0x0010
+#define IRQ_MASK_HIGH_OFF	0x0014
+
+#define TIMER_VIRT_BASE		(BRIDGE_VIRT_BASE + 0x0300)
+#define TIMER_PHYS_BASE		(BRIDGE_PHYS_BASE + 0x0300)
+
+#define L2_CONFIG_REG		(BRIDGE_VIRT_BASE + 0x0128)
+#define L2_WRITETHROUGH		0x00000010
+
+#define CLOCK_GATING_CTRL	(BRIDGE_VIRT_BASE + 0x11c)
+#define CGC_BIT_GE0		(0)
+#define CGC_BIT_PEX0		(2)
+#define CGC_BIT_USB0		(3)
+#define CGC_BIT_SDIO		(4)
+#define CGC_BIT_TSU		(5)
+#define CGC_BIT_DUNIT		(6)
+#define CGC_BIT_RUNIT		(7)
+#define CGC_BIT_XOR0		(8)
+#define CGC_BIT_AUDIO		(9)
+#define CGC_BIT_SATA0		(14)
+#define CGC_BIT_SATA1		(15)
+#define CGC_BIT_XOR1		(16)
+#define CGC_BIT_CRYPTO		(17)
+#define CGC_BIT_PEX1		(18)
+#define CGC_BIT_GE1		(19)
+#define CGC_BIT_TDM		(20)
+#define CGC_GE0			(1 << 0)
+#define CGC_PEX0		(1 << 2)
+#define CGC_USB0		(1 << 3)
+#define CGC_SDIO		(1 << 4)
+#define CGC_TSU			(1 << 5)
+#define CGC_DUNIT		(1 << 6)
+#define CGC_RUNIT		(1 << 7)
+#define CGC_XOR0		(1 << 8)
+#define CGC_AUDIO		(1 << 9)
+#define CGC_POWERSAVE           (1 << 11)
+#define CGC_SATA0		(1 << 14)
+#define CGC_SATA1		(1 << 15)
+#define CGC_XOR1		(1 << 16)
+#define CGC_CRYPTO		(1 << 17)
+#define CGC_PEX1		(1 << 18)
+#define CGC_GE1			(1 << 19)
+#define CGC_TDM			(1 << 20)
+#define CGC_RESERVED		(0x6 << 21)
+
+#define MEMORY_PM_CTRL		(BRIDGE_VIRT_BASE + 0x118)
+
+#endif
diff --git a/arch/arm/mach-avanta/include/mach/entry-macro.S b/arch/arm/mach-avanta/include/mach/entry-macro.S
new file mode 100644
index 0000000..82db29f
--- /dev/null
+++ b/arch/arm/mach-avanta/include/mach/entry-macro.S
@@ -0,0 +1,34 @@
+/*
+ * arch/arm/mach-kirkwood/include/mach/entry-macro.S
+ *
+ * Low-level IRQ helper macros for Marvell Kirkwood platforms
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <mach/bridge-regs.h>
+
+	.macro  get_irqnr_preamble, base, tmp
+	ldr	\base, =IRQ_VIRT_BASE
+	.endm
+
+	.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+	@ check low interrupts
+	ldr	\irqstat, [\base, #IRQ_CAUSE_LOW_OFF]
+	ldr	\tmp, [\base, #IRQ_MASK_LOW_OFF]
+	mov	\irqnr, #31
+	ands	\irqstat, \irqstat, \tmp
+	bne	1001f
+
+	@ if no low interrupts set, check high interrupts
+	ldr	\irqstat, [\base, #IRQ_CAUSE_HIGH_OFF]
+	ldr	\tmp, [\base, #IRQ_MASK_HIGH_OFF]
+	mov	\irqnr, #63
+	ands	\irqstat, \irqstat, \tmp
+
+	@ find first active interrupt source
+1001:	clzne	\irqstat, \irqstat
+	subne	\irqnr, \irqnr, \irqstat
+	.endm
diff --git a/arch/arm/mach-avanta/include/mach/hardware.h b/arch/arm/mach-avanta/include/mach/hardware.h
new file mode 100644
index 0000000..742b74f
--- /dev/null
+++ b/arch/arm/mach-avanta/include/mach/hardware.h
@@ -0,0 +1,14 @@
+/*
+ * arch/arm/mach-kirkwood/include/mach/hardware.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include "kirkwood.h"
+
+#endif
diff --git a/arch/arm/mach-avanta/include/mach/irqs.h b/arch/arm/mach-avanta/include/mach/irqs.h
new file mode 100644
index 0000000..2bf8161
--- /dev/null
+++ b/arch/arm/mach-avanta/include/mach/irqs.h
@@ -0,0 +1,65 @@
+/*
+ * arch/arm/mach-kirkwood/include/mach/irqs.h
+ *
+ * IRQ definitions for Marvell Kirkwood SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+/*
+ * Low Interrupt Controller
+ */
+#define IRQ_KIRKWOOD_HIGH_SUM	0
+#define IRQ_KIRKWOOD_BRIDGE	1
+#define IRQ_KIRKWOOD_HOST2CPU	2
+#define IRQ_KIRKWOOD_CPU2HOST	3
+#define IRQ_KIRKWOOD_XOR_00	5
+#define IRQ_KIRKWOOD_XOR_01	6
+#define IRQ_KIRKWOOD_XOR_10	7
+#define IRQ_KIRKWOOD_XOR_11	8
+#define IRQ_KIRKWOOD_PCIE	9
+#define IRQ_KIRKWOOD_PCIE1	10
+#define IRQ_KIRKWOOD_GE00_SUM	11
+#define IRQ_KIRKWOOD_GE01_SUM	15
+#define IRQ_KIRKWOOD_USB	19
+#define IRQ_KIRKWOOD_SATA	21
+#define IRQ_KIRKWOOD_CRYPTO	22
+#define IRQ_KIRKWOOD_SPI	23
+#define IRQ_KIRKWOOD_I2S	24
+#define IRQ_KIRKWOOD_TS_0	26
+#define IRQ_KIRKWOOD_SDIO	28
+#define IRQ_KIRKWOOD_TWSI	29
+#define IRQ_KIRKWOOD_AVB	30
+#define IRQ_KIRKWOOD_TDMI	31
+
+/*
+ * High Interrupt Controller
+ */
+#define IRQ_KIRKWOOD_UART_0	33
+#define IRQ_KIRKWOOD_UART_1	34
+#define IRQ_KIRKWOOD_GPIO_LOW_0_7	35
+#define IRQ_KIRKWOOD_GPIO_LOW_8_15	36
+#define IRQ_KIRKWOOD_GPIO_LOW_16_23	37
+#define IRQ_KIRKWOOD_GPIO_LOW_24_31	38
+#define IRQ_KIRKWOOD_GPIO_HIGH_0_7	39
+#define IRQ_KIRKWOOD_GPIO_HIGH_8_15	40
+#define IRQ_KIRKWOOD_GPIO_HIGH_16_23	41
+#define IRQ_KIRKWOOD_GE00_ERR	46
+#define IRQ_KIRKWOOD_GE01_ERR	47
+#define IRQ_KIRKWOOD_RTC        53
+
+/*
+ * KIRKWOOD General Purpose Pins
+ */
+#define IRQ_KIRKWOOD_GPIO_START	64
+#define NR_GPIO_IRQS		50
+
+#define NR_IRQS			(IRQ_KIRKWOOD_GPIO_START + NR_GPIO_IRQS)
+
+
+#endif
diff --git a/arch/arm/mach-avanta/include/mach/kirkwood.h b/arch/arm/mach-avanta/include/mach/kirkwood.h
new file mode 100644
index 0000000..92976ce
--- /dev/null
+++ b/arch/arm/mach-avanta/include/mach/kirkwood.h
@@ -0,0 +1,142 @@
+/*
+ * arch/arm/mach-kirkwood/include/mach/kirkwood.h
+ *
+ * Generic definitions for Marvell Kirkwood SoC flavors:
+ *  88F6180, 88F6192 and 88F6281.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_KIRKWOOD_H
+#define __ASM_ARCH_KIRKWOOD_H
+
+/*
+ * Marvell Kirkwood address maps.
+ *
+ * phys
+ * e0000000	PCIe #0 Memory space
+ * e8000000	PCIe #1 Memory space
+ * f1000000	on-chip peripheral registers
+ * f2000000	PCIe #0 I/O space
+ * f3000000	PCIe #1 I/O space
+ * f4000000	NAND controller address window
+ * f5000000	Security Accelerator SRAM
+ *
+ * virt		phys		size
+ * fed00000	f1000000	1M	on-chip peripheral registers
+ * fee00000	f2000000	1M	PCIe #0 I/O space
+ * fef00000	f3000000	1M	PCIe #1 I/O space
+ */
+
+#define KIRKWOOD_SRAM_PHYS_BASE		0xf5000000
+#define KIRKWOOD_SRAM_SIZE		SZ_2K
+
+#define KIRKWOOD_NAND_MEM_PHYS_BASE	0xf4000000
+#define KIRKWOOD_NAND_MEM_SIZE		SZ_1K
+
+#define KIRKWOOD_PCIE1_IO_PHYS_BASE	0xf3000000
+#define KIRKWOOD_PCIE1_IO_BUS_BASE	0x00010000
+#define KIRKWOOD_PCIE1_IO_SIZE		SZ_64K
+
+#define KIRKWOOD_PCIE_IO_PHYS_BASE	0xf2000000
+#define KIRKWOOD_PCIE_IO_BUS_BASE	0x00000000
+#define KIRKWOOD_PCIE_IO_SIZE		SZ_64K
+
+#define KIRKWOOD_REGS_PHYS_BASE		0xf1000000
+#define KIRKWOOD_REGS_VIRT_BASE		IOMEM(0xfed00000)
+#define KIRKWOOD_REGS_SIZE		SZ_1M
+
+#define KIRKWOOD_PCIE_MEM_PHYS_BASE	0xe0000000
+#define KIRKWOOD_PCIE_MEM_BUS_BASE	0xe0000000
+#define KIRKWOOD_PCIE_MEM_SIZE		SZ_128M
+
+#define KIRKWOOD_PCIE1_MEM_PHYS_BASE	0xe8000000
+#define KIRKWOOD_PCIE1_MEM_BUS_BASE	0xe8000000
+#define KIRKWOOD_PCIE1_MEM_SIZE		SZ_128M
+
+/*
+ * Register Map
+ */
+#define DDR_VIRT_BASE		(KIRKWOOD_REGS_VIRT_BASE + 0x00000)
+#define DDR_PHYS_BASE           (KIRKWOOD_REGS_PHYS_BASE + 0x00000)
+#define  DDR_WINDOW_CPU_BASE    (DDR_PHYS_BASE + 0x1500)
+#define  DDR_WINDOW_CPU_SZ      (0x20)
+#define DDR_OPERATION_BASE	(DDR_PHYS_BASE + 0x1418)
+
+#define DEV_BUS_PHYS_BASE	(KIRKWOOD_REGS_PHYS_BASE + 0x10000)
+#define DEV_BUS_VIRT_BASE	(KIRKWOOD_REGS_VIRT_BASE + 0x10000)
+#define  SAMPLE_AT_RESET	(DEV_BUS_VIRT_BASE + 0x0030)
+#define  DEVICE_ID		(DEV_BUS_VIRT_BASE + 0x0034)
+#define  GPIO_LOW_VIRT_BASE	(DEV_BUS_VIRT_BASE + 0x0100)
+#define  GPIO_HIGH_VIRT_BASE	(DEV_BUS_VIRT_BASE + 0x0140)
+#define  RTC_PHYS_BASE		(DEV_BUS_PHYS_BASE + 0x0300)
+#define  SPI_PHYS_BASE		(DEV_BUS_PHYS_BASE + 0x0600)
+#define  I2C_PHYS_BASE		(DEV_BUS_PHYS_BASE + 0x1000)
+#define  UART0_PHYS_BASE	(DEV_BUS_PHYS_BASE + 0x2000)
+#define  UART0_VIRT_BASE	(DEV_BUS_VIRT_BASE + 0x2000)
+#define  UART1_PHYS_BASE	(DEV_BUS_PHYS_BASE + 0x2100)
+#define  UART1_VIRT_BASE	(DEV_BUS_VIRT_BASE + 0x2100)
+
+#define BRIDGE_VIRT_BASE	(KIRKWOOD_REGS_VIRT_BASE + 0x20000)
+#define BRIDGE_PHYS_BASE	(KIRKWOOD_REGS_PHYS_BASE + 0x20000)
+#define  BRIDGE_WINS_BASE       (BRIDGE_PHYS_BASE)
+#define  BRIDGE_WINS_SZ         (0x80)
+
+#define CRYPTO_PHYS_BASE	(KIRKWOOD_REGS_PHYS_BASE + 0x30000)
+
+#define PCIE_VIRT_BASE		(KIRKWOOD_REGS_VIRT_BASE + 0x40000)
+#define PCIE_LINK_CTRL		(PCIE_VIRT_BASE + 0x70)
+#define PCIE_STATUS		(PCIE_VIRT_BASE + 0x1a04)
+#define PCIE1_VIRT_BASE		(KIRKWOOD_REGS_VIRT_BASE + 0x44000)
+#define PCIE1_LINK_CTRL		(PCIE1_VIRT_BASE + 0x70)
+#define PCIE1_STATUS		(PCIE1_VIRT_BASE + 0x1a04)
+
+#define USB_PHYS_BASE		(KIRKWOOD_REGS_PHYS_BASE + 0x50000)
+
+#define XOR0_PHYS_BASE		(KIRKWOOD_REGS_PHYS_BASE + 0x60800)
+#define XOR0_VIRT_BASE		(KIRKWOOD_REGS_VIRT_BASE + 0x60800)
+#define XOR1_PHYS_BASE		(KIRKWOOD_REGS_PHYS_BASE + 0x60900)
+#define XOR1_VIRT_BASE		(KIRKWOOD_REGS_VIRT_BASE + 0x60900)
+#define XOR0_HIGH_PHYS_BASE	(KIRKWOOD_REGS_PHYS_BASE + 0x60A00)
+#define XOR0_HIGH_VIRT_BASE	(KIRKWOOD_REGS_VIRT_BASE + 0x60A00)
+#define XOR1_HIGH_PHYS_BASE	(KIRKWOOD_REGS_PHYS_BASE + 0x60B00)
+#define XOR1_HIGH_VIRT_BASE	(KIRKWOOD_REGS_VIRT_BASE + 0x60B00)
+
+#define GE00_PHYS_BASE		(KIRKWOOD_REGS_PHYS_BASE + 0x70000)
+#define GE01_PHYS_BASE		(KIRKWOOD_REGS_PHYS_BASE + 0x74000)
+
+#define SATA_PHYS_BASE		(KIRKWOOD_REGS_PHYS_BASE + 0x80000)
+#define SATA_VIRT_BASE		(KIRKWOOD_REGS_VIRT_BASE + 0x80000)
+#define SATA0_IF_CTRL		(SATA_VIRT_BASE + 0x2050)
+#define SATA0_PHY_MODE_2	(SATA_VIRT_BASE + 0x2330)
+#define SATA1_IF_CTRL		(SATA_VIRT_BASE + 0x4050)
+#define SATA1_PHY_MODE_2	(SATA_VIRT_BASE + 0x4330)
+
+#define SDIO_PHYS_BASE		(KIRKWOOD_REGS_PHYS_BASE + 0x90000)
+
+#define AUDIO_PHYS_BASE		(KIRKWOOD_REGS_PHYS_BASE + 0xA0000)
+#define AUDIO_VIRT_BASE		(KIRKWOOD_REGS_VIRT_BASE + 0xA0000)
+
+/*
+ * Supported devices and revisions.
+ */
+#define MV88F6281_DEV_ID	0x6281
+#define MV88F6281_REV_Z0	0
+#define MV88F6281_REV_A0	2
+#define MV88F6281_REV_A1	3
+
+#define MV88F6192_DEV_ID	0x6192
+#define MV88F6192_REV_Z0	0
+#define MV88F6192_REV_A0	2
+#define MV88F6192_REV_A1	3
+
+#define MV88F6180_DEV_ID	0x6180
+#define MV88F6180_REV_A0	2
+#define MV88F6180_REV_A1	3
+
+#define MV88F6282_DEV_ID	0x6282
+#define MV88F6282_REV_A0	0
+#define MV88F6282_REV_A1	1
+#endif
diff --git a/arch/arm/mach-avanta/include/mach/timex.h b/arch/arm/mach-avanta/include/mach/timex.h
new file mode 100644
index 0000000..c923cd1
--- /dev/null
+++ b/arch/arm/mach-avanta/include/mach/timex.h
@@ -0,0 +1,10 @@
+/*
+ * arch/arm/mach-kirkwood/include/mach/timex.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#define CLOCK_TICK_RATE		(100 * HZ)
+
diff --git a/arch/arm/mach-avanta/include/mach/uncompress.h b/arch/arm/mach-avanta/include/mach/uncompress.h
new file mode 100644
index 0000000..5bca553
--- /dev/null
+++ b/arch/arm/mach-avanta/include/mach/uncompress.h
@@ -0,0 +1,46 @@
+/*
+ * arch/arm/mach-kirkwood/include/mach/uncompress.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/serial_reg.h>
+#include <mach/kirkwood.h>
+
+#define SERIAL_BASE	((unsigned char *)UART0_PHYS_BASE)
+
+static void putc(const char c)
+{
+	unsigned char *base = SERIAL_BASE;
+	int i;
+
+	for (i = 0; i < 0x1000; i++) {
+		if (base[UART_LSR << 2] & UART_LSR_THRE)
+			break;
+		barrier();
+	}
+
+	base[UART_TX << 2] = c;
+}
+
+static void flush(void)
+{
+	unsigned char *base = SERIAL_BASE;
+	unsigned char mask;
+	int i;
+
+	mask = UART_LSR_TEMT | UART_LSR_THRE;
+
+	for (i = 0; i < 0x1000; i++) {
+		if ((base[UART_LSR << 2] & mask) == mask)
+			break;
+		barrier();
+	}
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
diff --git a/arch/arm/mach-avanta/pcie.c b/arch/arm/mach-avanta/pcie.c
new file mode 100644
index 0000000..12d86f3
--- /dev/null
+++ b/arch/arm/mach-avanta/pcie.c
@@ -0,0 +1,296 @@
+/*
+ * arch/arm/mach-kirkwood/pcie.c
+ *
+ * PCIe functions for Marvell Kirkwood SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/mbus.h>
+#include <video/vga.h>
+#include <asm/irq.h>
+#include <asm/mach/pci.h>
+#include <plat/pcie.h>
+#include <mach/bridge-regs.h>
+#include "common.h"
+
+/* These can go away once Kirkwood uses the mvebu-mbus DT binding */
+#define KIRKWOOD_MBUS_PCIE0_MEM_TARGET    0x4
+#define KIRKWOOD_MBUS_PCIE0_MEM_ATTR      0xe8
+#define KIRKWOOD_MBUS_PCIE0_IO_TARGET     0x4
+#define KIRKWOOD_MBUS_PCIE0_IO_ATTR       0xe0
+#define KIRKWOOD_MBUS_PCIE1_MEM_TARGET    0x4
+#define KIRKWOOD_MBUS_PCIE1_MEM_ATTR      0xd8
+#define KIRKWOOD_MBUS_PCIE1_IO_TARGET     0x4
+#define KIRKWOOD_MBUS_PCIE1_IO_ATTR       0xd0
+
+static void kirkwood_enable_pcie_clk(const char *port)
+{
+	struct clk *clk;
+
+	clk = clk_get_sys("pcie", port);
+	if (IS_ERR(clk)) {
+		pr_err("PCIE clock %s missing\n", port);
+		return;
+	}
+	clk_prepare_enable(clk);
+	clk_put(clk);
+}
+
+/* This function is called very early in the boot when probing the
+   hardware to determine what we actually are, and what rate tclk is
+   ticking at. Hence calling kirkwood_enable_pcie_clk() is not
+   possible since the clk tree has not been created yet. */
+void kirkwood_enable_pcie(void)
+{
+	u32 curr = readl(CLOCK_GATING_CTRL);
+	if (!(curr & CGC_PEX0))
+		writel(curr | CGC_PEX0, CLOCK_GATING_CTRL);
+}
+
+void kirkwood_pcie_id(u32 *dev, u32 *rev)
+{
+	kirkwood_enable_pcie();
+	*dev = orion_pcie_dev_id(PCIE_VIRT_BASE);
+	*rev = orion_pcie_rev(PCIE_VIRT_BASE);
+}
+
+struct pcie_port {
+	u8			root_bus_nr;
+	void __iomem		*base;
+	spinlock_t		conf_lock;
+	int			irq;
+	struct resource		res;
+};
+
+static int pcie_port_map[2];
+static int num_pcie_ports;
+
+static int pcie_valid_config(struct pcie_port *pp, int bus, int dev)
+{
+	/*
+	 * Don't go out when trying to access --
+	 * 1. nonexisting device on local bus
+	 * 2. where there's no device connected (no link)
+	 */
+	if (bus == pp->root_bus_nr && dev == 0)
+		return 1;
+
+	if (!orion_pcie_link_up(pp->base))
+		return 0;
+
+	if (bus == pp->root_bus_nr && dev != 1)
+		return 0;
+
+	return 1;
+}
+
+
+/*
+ * PCIe config cycles are done by programming the PCIE_CONF_ADDR register
+ * and then reading the PCIE_CONF_DATA register. Need to make sure these
+ * transactions are atomic.
+ */
+
+static int pcie_rd_conf(struct pci_bus *bus, u32 devfn, int where,
+			int size, u32 *val)
+{
+	struct pci_sys_data *sys = bus->sysdata;
+	struct pcie_port *pp = sys->private_data;
+	unsigned long flags;
+	int ret;
+
+	if (pcie_valid_config(pp, bus->number, PCI_SLOT(devfn)) == 0) {
+		*val = 0xffffffff;
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+
+	spin_lock_irqsave(&pp->conf_lock, flags);
+	ret = orion_pcie_rd_conf(pp->base, bus, devfn, where, size, val);
+	spin_unlock_irqrestore(&pp->conf_lock, flags);
+
+	return ret;
+}
+
+static int pcie_wr_conf(struct pci_bus *bus, u32 devfn,
+			int where, int size, u32 val)
+{
+	struct pci_sys_data *sys = bus->sysdata;
+	struct pcie_port *pp = sys->private_data;
+	unsigned long flags;
+	int ret;
+
+	if (pcie_valid_config(pp, bus->number, PCI_SLOT(devfn)) == 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	spin_lock_irqsave(&pp->conf_lock, flags);
+	ret = orion_pcie_wr_conf(pp->base, bus, devfn, where, size, val);
+	spin_unlock_irqrestore(&pp->conf_lock, flags);
+
+	return ret;
+}
+
+static struct pci_ops pcie_ops = {
+	.read = pcie_rd_conf,
+	.write = pcie_wr_conf,
+};
+
+static void __init pcie0_ioresources_init(struct pcie_port *pp)
+{
+	pp->base = PCIE_VIRT_BASE;
+	pp->irq	= IRQ_KIRKWOOD_PCIE;
+
+	/*
+	 * IORESOURCE_MEM
+	 */
+	pp->res.name = "PCIe 0 MEM";
+	pp->res.start = KIRKWOOD_PCIE_MEM_PHYS_BASE;
+	pp->res.end = pp->res.start + KIRKWOOD_PCIE_MEM_SIZE - 1;
+	pp->res.flags = IORESOURCE_MEM;
+}
+
+static void __init pcie1_ioresources_init(struct pcie_port *pp)
+{
+	pp->base = PCIE1_VIRT_BASE;
+	pp->irq	= IRQ_KIRKWOOD_PCIE1;
+
+	/*
+	 * IORESOURCE_MEM
+	 */
+	pp->res.name = "PCIe 1 MEM";
+	pp->res.start = KIRKWOOD_PCIE1_MEM_PHYS_BASE;
+	pp->res.end = pp->res.start + KIRKWOOD_PCIE1_MEM_SIZE - 1;
+	pp->res.flags = IORESOURCE_MEM;
+}
+
+static int __init kirkwood_pcie_setup(int nr, struct pci_sys_data *sys)
+{
+	struct pcie_port *pp;
+	int index;
+
+	if (nr >= num_pcie_ports)
+		return 0;
+
+	index = pcie_port_map[nr];
+	pr_info("PCI: bus%d uses PCIe port %d\n", sys->busnr, index);
+
+	pp = kzalloc(sizeof(*pp), GFP_KERNEL);
+	if (!pp)
+		panic("PCIe: failed to allocate pcie_port data");
+	sys->private_data = pp;
+	pp->root_bus_nr = sys->busnr;
+	spin_lock_init(&pp->conf_lock);
+
+	switch (index) {
+	case 0:
+		kirkwood_enable_pcie_clk("0");
+		pcie0_ioresources_init(pp);
+		pci_ioremap_io(SZ_64K * sys->busnr, KIRKWOOD_PCIE_IO_PHYS_BASE);
+		break;
+	case 1:
+		kirkwood_enable_pcie_clk("1");
+		pcie1_ioresources_init(pp);
+		pci_ioremap_io(SZ_64K * sys->busnr,
+			       KIRKWOOD_PCIE1_IO_PHYS_BASE);
+		break;
+	default:
+		panic("PCIe setup: invalid controller %d", index);
+	}
+
+	if (request_resource(&iomem_resource, &pp->res))
+		panic("Request PCIe%d Memory resource failed\n", index);
+
+	pci_add_resource_offset(&sys->resources, &pp->res, sys->mem_offset);
+
+	/*
+	 * Generic PCIe unit setup.
+	 */
+	orion_pcie_set_local_bus_nr(pp->base, sys->busnr);
+
+	orion_pcie_setup(pp->base);
+
+	return 1;
+}
+
+/*
+ * The root complex has a hardwired class of PCI_CLASS_MEMORY_OTHER, when it
+ * is operating as a root complex this needs to be switched to
+ * PCI_CLASS_BRIDGE_HOST or Linux will errantly try to process the BAR's on
+ * the device. Decoding setup is handled by the orion code.
+ */
+static void rc_pci_fixup(struct pci_dev *dev)
+{
+	if (dev->bus->parent == NULL && dev->devfn == 0) {
+		int i;
+
+		dev->class &= 0xff;
+		dev->class |= PCI_CLASS_BRIDGE_HOST << 8;
+		for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
+			dev->resource[i].start = 0;
+			dev->resource[i].end   = 0;
+			dev->resource[i].flags = 0;
+		}
+	}
+}
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL, PCI_ANY_ID, rc_pci_fixup);
+
+static int __init kirkwood_pcie_map_irq(const struct pci_dev *dev, u8 slot,
+	u8 pin)
+{
+	struct pci_sys_data *sys = dev->sysdata;
+	struct pcie_port *pp = sys->private_data;
+
+	return pp->irq;
+}
+
+static struct hw_pci kirkwood_pci __initdata = {
+	.setup		= kirkwood_pcie_setup,
+	.map_irq	= kirkwood_pcie_map_irq,
+	.ops            = &pcie_ops,
+};
+
+static void __init add_pcie_port(int index, void __iomem *base)
+{
+	pcie_port_map[num_pcie_ports++] = index;
+	pr_info("Kirkwood PCIe port %d: link %s\n", index,
+		orion_pcie_link_up(base) ? "up" : "down");
+}
+
+void __init kirkwood_pcie_init(unsigned int portmask)
+{
+	mvebu_mbus_add_window_remap_by_id(KIRKWOOD_MBUS_PCIE0_IO_TARGET,
+					  KIRKWOOD_MBUS_PCIE0_IO_ATTR,
+					  KIRKWOOD_PCIE_IO_PHYS_BASE,
+					  KIRKWOOD_PCIE_IO_SIZE,
+					  KIRKWOOD_PCIE_IO_BUS_BASE);
+	mvebu_mbus_add_window_by_id(KIRKWOOD_MBUS_PCIE0_MEM_TARGET,
+				    KIRKWOOD_MBUS_PCIE0_MEM_ATTR,
+				    KIRKWOOD_PCIE_MEM_PHYS_BASE,
+				    KIRKWOOD_PCIE_MEM_SIZE);
+	mvebu_mbus_add_window_remap_by_id(KIRKWOOD_MBUS_PCIE1_IO_TARGET,
+					  KIRKWOOD_MBUS_PCIE1_IO_ATTR,
+					  KIRKWOOD_PCIE1_IO_PHYS_BASE,
+					  KIRKWOOD_PCIE1_IO_SIZE,
+					  KIRKWOOD_PCIE1_IO_BUS_BASE);
+	mvebu_mbus_add_window_by_id(KIRKWOOD_MBUS_PCIE1_MEM_TARGET,
+				    KIRKWOOD_MBUS_PCIE1_MEM_ATTR,
+				    KIRKWOOD_PCIE1_MEM_PHYS_BASE,
+				    KIRKWOOD_PCIE1_MEM_SIZE);
+
+	vga_base = KIRKWOOD_PCIE_MEM_PHYS_BASE;
+
+	if (portmask & KW_PCIE0)
+		add_pcie_port(0, PCIE_VIRT_BASE);
+
+	if (portmask & KW_PCIE1)
+		add_pcie_port(1, PCIE1_VIRT_BASE);
+
+	kirkwood_pci.nr_controllers = num_pcie_ports;
+	pci_common_init(&kirkwood_pci);
+}
diff --git a/arch/arm/mach-avanta/pm.c b/arch/arm/mach-avanta/pm.c
new file mode 100644
index 0000000..c6ab8d9
--- /dev/null
+++ b/arch/arm/mach-avanta/pm.c
@@ -0,0 +1,73 @@
+/*
+ * Power Management driver for Marvell Kirkwood SoCs
+ *
+ * Copyright (C) 2013 Ezequiel Garcia <ezequiel@free-electrons.com>
+ * Copyright (C) 2010 Simon Guinot <sguinot@lacie.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License,
+ * version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/suspend.h>
+#include <linux/io.h>
+#include <mach/bridge-regs.h>
+#include "common.h"
+
+static void __iomem *ddr_operation_base;
+
+static void kirkwood_low_power(void)
+{
+	u32 mem_pm_ctrl;
+
+	mem_pm_ctrl = readl(MEMORY_PM_CTRL);
+
+	/* Set peripherals to low-power mode */
+	writel_relaxed(~0, MEMORY_PM_CTRL);
+
+	/* Set DDR in self-refresh */
+	writel_relaxed(0x7, ddr_operation_base);
+
+	/*
+	 * Set CPU in wait-for-interrupt state.
+	 * This disables the CPU core clocks,
+	 * the array clocks, and also the L2 controller.
+	 */
+	cpu_do_idle();
+
+	writel_relaxed(mem_pm_ctrl, MEMORY_PM_CTRL);
+}
+
+static int kirkwood_suspend_enter(suspend_state_t state)
+{
+	switch (state) {
+	case PM_SUSPEND_STANDBY:
+		kirkwood_low_power();
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int kirkwood_pm_valid_standby(suspend_state_t state)
+{
+	return state == PM_SUSPEND_STANDBY;
+}
+
+static const struct platform_suspend_ops kirkwood_suspend_ops = {
+	.enter = kirkwood_suspend_enter,
+	.valid = kirkwood_pm_valid_standby,
+};
+
+void __init kirkwood_pm_init(void)
+{
+	ddr_operation_base = ioremap(DDR_OPERATION_BASE, 4);
+	suspend_set_ops(&kirkwood_suspend_ops);
+}
diff --git a/arch/arm/mm/Kconfig b/arch/arm/mm/Kconfig
index ca8ecde..70e7908 100644
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@ -854,7 +854,7 @@ config OUTER_CACHE_SYNC
 
 config CACHE_FEROCEON_L2
 	bool "Enable the Feroceon L2 cache controller"
-	depends on ARCH_KIRKWOOD || ARCH_MV78XX0
+	depends on ARCH_KIRKWOOD || ARCH_MV78XX0 || ARCH_AVANTA
 	default y
 	select OUTER_CACHE
 	help
-- 
2.0.3

